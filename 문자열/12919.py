"""수빈이는 A와 B로만 이루어진 영어 단어 존재한다는 사실에 놀랐다. 대표적인 예로 AB (Abdominal의 약자), BAA (양의 울음 소리), AA (용암의 종류), ABBA (스웨덴 팝 그룹)이 있다.

이런 사실에 놀란 수빈이는 간단한 게임을 만들기로 했다. 두 문자열 S와 T가 주어졌을 때, S를 T로 바꾸는 게임이다. 문자열을 바꿀 때는 다음과 같은 두 가지 연산만 가능하다.

문자열의 뒤에 A를 추가한다.
문자열의 뒤에 B를 추가하고 문자열을 뒤집는다.
주어진 조건을 이용해서 S를 T로 만들 수 있는지 없는지 알아내는 프로그램을 작성하시오. """
import sys
input = sys.stdin.readline
s = input().rstrip()
t = input().rstrip()

def dfs(t):

    if len(t)==len(s):
        if t==s:
            print(1)
            sys.exit(0)
        else:
            return 0

    if t[-1]=='A':
        dfs(t[:-1])
    if t[0]=='B':
        dfs(t[::-1][:-1])
dfs(t)
print(0)

"""
처음에는 s를 이용해서 t까지했다가
t를 이용해서 s를 만드는 접근까지는 괜찮았는데
맨앞과 맨 뒤가 a일때는 확실하게 a를 빼는게 맞고
맨앞과 뒤가 b일때는 확실하게 b를 빼는게 맞는데
그 둘 중에 하나일때는 어떻게 해야될지 감을 못잡았음

>>이것 자체가 경우의 수기 때문에 이런 경우일때는 dfs를 이용해서 경우의 수를 계속 구해주는게 핵심임
특히! if else로 나누는게 아니라 if a가 맨 뒤일때, if b가 맨 앞일때 를 두번 해서 둘다 경우의 수로 가서
결국 맞는 경우가 있으면 1을 리턴하는게 포인트

2. 굳이 이런거 할때 def해줄 필요 없고,
문자열 그냥 [:-1], [::-1] 이런식으로 파싱해주면됨.
어차피 그게 dfs돌릴때 더 편하기도 하니까...
암튼 dfs를 활용해서 문자열 여러 경우의 수 접근하는 법 생각하는게 좀 필요할듯

++로 이럴때 return 1, 0 으로 하지말고
딱 맞은 경우의 수를 찾았으면 print(1)을 하고 sys.exit(0) 을 해서 시스템을 끝내주는 코딩이 필요함
또, return값 이용해서 print해주려 하지 말고, 아무것도 1이되는게 없으면 어차피 없다는 뜻이니까
그냥 print(0) 으로 처리해주면 됨

+이 접근 자체도 그때 n과m에서 계속 했던건데..ㅠ 그동안 다 까먹었네 이래서 복습이 중요한듯
dx,dy 해서 하는 bfs는 이제 대부분은 잘 하는듯? 자바로 할때 바보같이 생각하는 거 빼면ㅎ;"""
